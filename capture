#!/bin/sh

# Source this from your git hooks. It will buffer and stdout and stderr data
# and only display it if your scripts exits with a non-zero exit code.
# Globals - do not use or overwrite these:
#    variable $capture_outfile
#    function $capture_on_exit() {}
#    trap on EXIT SIGHUP SIGINT SIGTERM
#    file descriptors: 11, 12
# Example usage:
#   . capture # will source this file from your script

# To be run when this script receives the EXIT signal
function capture_on_exit () {
	# Store the exit code
	result=$?

	# Check our options
	local OPTIND OPTERR OPTARG opt quiet
	while getopts ":q" opt; do
		case $opt in
			q) quiet=1;;
			\?) ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	
	# Fix our stdout and stderr
	exec 1>&11 2>&12 11>&- 12>&-

	# If we have a non-zero exit code, display the buffered output
	if [[ $result -ne 0 ]]; then
		[[ -z $quiet ]] && echo "Exiting with error code $result "
		cat $1
	fi

	# Remove the buffered output file
	rm -f $1
}

# Create the temorary output buffer
capture_outfile=$(mktemp)

# Store stdout and stderr, then them to the buffer
exec 11>&1 12>&2 &>$capture_outfile

# Set our exit trap to disply any errors and do our clean up 
trap "capture_on_exit $@ $capture_outfile" EXIT SIGHUP SIGINT SIGTERM
