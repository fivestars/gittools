#! /bin/bash

function _help {
    echo "\
Usage: git subrepo [list]
   or: git subrepo install [--local] [--global] [--core]
   or: git subrepo uninstall [--local] [--global] [--core]
   or: git subrepo add [-r] [<dir>] <remote> [<pin>]
   or: git subrepo rm [-r] <dir1> <dir2>...
   or: git subrepo checkout <dir> [<pin>]
   or: git subrepo update [--top] [--rebase] [--choice=s|k|o] [-r] [--file=<.gitrepos file>] [<dir1>] [<dir2>]...
   or: git subrepo publish [-m <message>] [-p]
   or: git subrepo help

Files:
    .gitrepos: This is where git-subrepo stores its tracking information.
               Like .gitignore, it is intended to be committed like any
               other file in your repository. Each line is an entry
               that describes a sub-repo. The lines have the following
               format:
                   <path> <remote> [<pin>]

               <path>: The filepath location of the cloned sub-repo.
                       It is relative to the top-level directory of the
                       parent repository (the one containing the .gitrepos
                       file).
               <remote>: The git url of the sub-repo. If this is a file://
                         url, it must be an absolute path.
               <pin>: A branch or commit in the sub-repo.
                      git-subrepo will checkout this pin upon 'add' and
                      'update' and will use it as a basis for detecting
                      changes during other operations. If not present, 
                      git-subrepo will not monitor changes in that sub-repo
                      and expect that you are managing it manually.

Operations:
    list: Lists the current sub-repos for this repository.

    install: Installs 'git-subrepo' into any of three locations.
             --local: The repository's aliases (default)
             --global: Your global aliases
             --core: Copies this file into this machine's git core 
                     directory. Any 'subrepo' aliases will no longer
                     be effective.

    uninstall: Undoes the effects of 'install'.

    add: Adds a new repository as a sub-repo. This will create an
         entry in the .gitrepos file and clone the repository
         to <dir>.
         If <pin> is given, the repository will be checked out to
         that branch or commit, and it will be recorded in the 
         sub-repo's .gitrepos entry.

         -r: 'git subrepo update -r' the new sub-repo.

    rm: Removes a sub-repo from this repository. This removes the
        sub-repo's entry from the .gitrepos file.

        -r: the sub-repo's directory will be removed from the
            working directory as well.

    checkout: Checks out a sub-repo to the given <pin>. 
              This branch or commit will be recorded in the sub-repo's
              .gitrepos entry.
              If no <pin> is given, the sub-repo's pin value will
              be cleared from the .gitrepos file.

    update: Clones any new repositories found in the .gitrepos
            file and pulls down any changes for the existing
            sub-repos.
            If the sub-repo's remote differs from the one specified
            and there are unpushed changes in that sub-repo, you
            will be prompted to resolve these changes before
            continuing.
            If a the sub-repo has a pin in the .gitrepos file and
            it differs from the sub-repo's currently checked out
            branch or commit, you will be given a choice of how
            to handle it (switch, keep, overwrite).

            --top: Perform a pull on this top-level repo first.
            --rebase: Perform a rebase rather than a merge when
                      pulling commits from the sub-repos' origins.
                      Also used with the --top pull.
            --choice: Use this value rather than waiting for user
                      input when prompted to handle a difference
                      in .gitrepos pin and current pin.
            -r: Recurse through our sub-repos and update them as well.
                Any specified <dir>s and the argument to the --file
                option will only apply to the top-level repository 
                in which this command is being invoked.
            --file: Use the given file rather than the local 
                    .gitrepos file.

    publish: Safely pushes the current .gitrepos file.
             It iterates through the sub-repo list in the .gitrepos
             file and verifies that they are checked out locally 
             and that each pin(if present) exists in its remote 
             repository.
             You are then prompted to continue with the add-commit-push
             of the .gitrepos file.

             -p: The prompt will be suppressed, and it will proceed
                 as if you had entered 'y'.
             -m: The commit message.

    help: Displays this help message.
"
}

function _install {
    local TOKENS TOKEN LOCAL GLOBAL CORE CHOICE 
    [[ -z $@ ]] && LOCAL=2
    read -a TOKENS <<< "$@"
    for TOKEN in ${TOKENS[@]}; do
	case $TOKEN in
	    --local) shift; LOCAL=1;;
	    --global) shift; [[ $LOCAL == 2 ]] && LOCAL=; GLOBAL=1;;
	    --core) shift; [[ $LOCAL == 2 ]] && LOCAL=; CORE=1;;
	    *) echo "Unknown option: $TOKEN"; return 1;; 
	esac
    done
    
    if [[ -n $LOCAL ]]; then
	git config alias.subrepo '!$(git rev-parse --show-toplevel)/git-subrepo' && \
	    echo "Added to your repository's aliases."
    fi

    if [[ -n $GLOBAL ]]; then
	echo "!$(git rev-parse --show-toplevel)/git-subrepo" && \
	git config --global alias.subrepo "!$(git rev-parse --show-toplevel)/git-subrepo" && \
	    echo "Added to your global aliases."
    fi

    if [[ -n $CORE ]]; then
	echo "This will supercede any subrepo aliases on this machine."
	echo -n "Continue? (y/N) "
	read CHOICE
	case $CHOICE in
	    y|Y) cp $BASH_SOURCE $(git --exec-path) && \
		echo "Copied to $(git --exec-path)/git-subrepo" || \
		echo "Could not copy to $(git --exec-path)/git-subrepo";;
	esac
    fi
}

function _uninstall {
    local TOKENS TOKEN LOCAL GLOBAL CORE CHOICE
    [[ -z $@ ]] && LOCAL=2
    read -a TOKENS <<< "$@"
    for TOKEN in ${TOKENS[@]}; do
	case $TOKEN in
	    --local) shift; LOCAL=1;;
	    --global) shift; [[ $LOCAL == 2 ]] && LOCAL=; GLOBAL=1;;
	    --core) shift; [[ $LOCAL == 2 ]] && LOCAL=; CORE=1;;
	esac
    done
    
    if [[ -n $LOCAL ]]; then
	git config --unset alias.subrepo && \
	    echo "Removed from your repository's aliases."
    fi

    if [[ -n $GLOBAL ]]; then
	git config --global --unset alias.subrepo && \
	    echo "Removed from your global aliases."
	
    fi

    if [[ -n $CORE && -e "$(git --exec-path)/git-subrepo" ]]; then
	echo "This will remove 'git subrepo' from this machine."
	echo -n "Continue? (y/N) "
	read CHOICE
	case $CHOICE in
	    y|Y) rm -f "$(git --exec-path)/git-subrepo" && \
		echo "Deleted $(git --exec-path)/git-subrepo" || \
		echo "Could not remove from $(git --exec-path)";;
	esac
    fi
}

function _add {
    local DIR REMOTE PIN RECURSE
    local OPTARG OPTIND OPTERR OPT DELETE DIR
    while getopts ":r" OPT; do
	case $OPT in
	    r) RECURSE=1;;
	esac
    done
    shift $((OPTIND-1))

    if echo $1 | grep -q "\.git$"; then
	read REMOTE PIN <<< $@
	DIR=$(echo $REMOTE | sed 's/\(.*[:/]\|^\)\([^:/]\+\)\.git/\2/')
    else
	read DIR REMOTE PIN <<< $@
    fi
    
    touch .gitrepos
    if grep -q "^$DIR " .gitrepos; then
	echo "Sub-repo already exists as "$(grep "^$DIR " .gitrepos) >&2
	return 1
    elif [[ -e $DIR ]]; then
	echo "$DIR is already present. Move aside or choose another location for your sub-repo." >&2
	return 1
    fi

    # Prevent the use of relative file paths
    if [[ ${REMOTE:0:1} != '/' && ${REMOTE:0:8} != 'file:///' && -e $REMOTE ]]; then
	echo "Will not add a repository using a relative filepath" >&2
	return 1
    fi

    if ! git clone $REMOTE $DIR; then
	echo "Failed to clone sub-repo" >&2
	return 1
    fi

    if [[ -n $PIN ]]; then
	if ! git rev-list --quiet $PIN -- &>/dev/null; then
	    echo "$PIN is not a valid branch or commit for this repository" >&2
	    return 1
	fi
	
	# Attempt to checkout $PIN for this sub-repo
	pushd $DIR >/dev/null
	if ! git checkout $PIN; then
	    echo "Failed to checkout $PIN" >&2
	    return 1
	fi
	popd >/dev/null
    fi
    
    echo $DIR $REMOTE $PIN >> .gitrepos
    echo /$DIR >> .gitignore
    
    if [[ -n $RECURSE && -e $DIR/.gitrepos ]]; then
	echo "Recursing to $DIR"
	pushd $DIR >/dev/null
	if ! $BASH_SOURCE update -r; then
	    echo "Failed to update $DIR" >&2
	    return 1
	fi
	popd >/dev/null
    fi
}

function _rm {
    local OPTARG OPTIND OPTERR OPT DELETE DIR
    while getopts ":r" OPT; do
	case $OPT in
	    r) DELETE=1;;
	esac
    done
    shift $((OPTIND-1))

    for DIR in $@; do
	if grep -q "^$DIR " .gitrepos; then
	    if [[ -n $DELETE ]]; then
		echo "Removing sub-repo record and directory"
		rm -rf $DIR
	    else
		echo "Removing sub-repo record, leaving directory"
	    fi
	    sed -i'' "/^$DIR /d;/^$/d" .gitrepos
	    if [[ -e .gitignore ]]; then
		sed -i'' "/^\/${DIR}$/d;/^$/d" .gitignore
	    fi
	else
	    echo "Unknown sub-repo" >&2
	fi
    done
}

function _update {
    local ARGS DELETE REPOS REPO DIR REMOTE PIN CPIN COMMIT TOP REBASE RECURSE FILE=.gitrepos LINE CHOICEOPT CHOICE
    
    local TOKENS TOKEN
    read -a TOKENS <<< "$@"
    for TOKEN in ${TOKENS[@]}; do
	case $TOKEN in
	    --rebase) shift; ARGS="${ARGS[@]} $TOKEN"; REBASE=$TOKEN;;
	    --top) shift; ARGS="${ARGS[@]} $TOKEN"; TOP=1;;
	    --choice=*) shift; ARGS="${ARGS[@]} $TOKEN"; CHOICEOPT=${TOKEN#--choice=};;
	    -r) shift; ARGS="${ARGS[@]} $TOKEN"; RECURSE=1;;
	    --file=*) shift; FILE=${TOKEN#--file=};;
	    *) [[ ${TOKEN:0:2} == "--" ]] && echo "Unknown option: $TOKEN" && return 1;;
	esac
    done
    REPOS="$@"

    # Make sure the .gitrepos file exists
    if [[ ! -e $FILE ]]; then
	echo "No such file or directory: $FILE" >&2
	return 1
    fi

    # Update the top-level repository, if requested
    if [[ -n $TOP ]]; then
	if ! git pull $REBASE; then
	    return 1
	fi
    fi

    # We need to save a reference to the outer stdin here since 
    # we want to read from the keyboard for user input and the 
    # while loop will have its own stdin for reading the .gitrepos
    # file.
    exec 10<&0

    while read LINE; do
	echo
	read DIR REMOTE PIN <<< $(echo $LINE)

	# See if the sub-repo is pinned to a particular commit.
	if [[ ${PIN:0:2} == "!!" ]]; then
	    COMMIT=1
	    PIN=${PIN:2}
	fi

	# First, check to see if the remote has changed. If so, make sure to preserve any
	# local, non-published changes. Otherwise, we can safely delete it and proceed
	# as if it's a brand new sub-repo.
	if [[ -e $DIR ]]; then
	    # The sub-repo directory is already present. Navigate to it.
	    pushd $DIR >/dev/null
	    
	    # If we detect that the sub-repo's remote has changed, force a manual intervention.
	    if ! git remote -v | grep -q "origin[[:space:]]\+$REMOTE"; then
		
		# Fetch remote changes so we can compare to latest data.
		if ! git fetch &>/dev/null; then
		    echo "Failed to fetch remote changes." >&2
		    return 1
		fi
		local MESSAGE=""
		[[ $(git ls-files -o --exclude-standard | wc -l) != 0 ]] && \
		    MESSAGE="$MESSAGE - new files\n"
		[[ $(git ls-files -dm | wc -l) != 0 ]] && \
		    MESSAGE="$MESSAGE - edits\n"
		[[ $(git diff --name-only --cached | wc -l) != 0 ]] && \
		    MESSAGE="$MESSAGE - staged changes\n"
		[[ $(git rev-list --all --not --remotes | wc -l) != 0 ]] && \
		    MESSAGE="$MESSAGE - local commits or stashed changes\n"

		if [[ -n $MESSAGE ]]; then
		    echo -e "\033[1;37;41m $DIR($PIN) -- $REMOTE \033[0m"
		    echo -e "Remote has changed for this sub-repo and unpublished local changes were found.\n${MESSAGE}Resolve these before continuing, or just delete this sub-repo directory and update again." >&2
		    return 1
		else
		    # It's safe to switch to the new remote, so delete the current sub-repo.
		    popd >/dev/null
		    rm -rf $DIR
		fi
	    else
		popd >/dev/null
	    fi
	fi
	
	# If the sub-repo directory doesn't exist, we must clone it down now
	if [[ ! -e $DIR ]]; then
	    echo -e "\033[1;37;42m $DIR($PIN) -- $REMOTE \033[0m"
	    if ! git clone $REMOTE $DIR; then
		echo "Failed to clone sub-repo" >&2
		return 1
	    fi
	    
	    if [[ -n $PIN ]]; then
		pushd $DIR >/dev/null
		if ! git checkout $PIN; then
		    echo "Failed to checkout $PIN" >&2
		    return 1
		fi
		popd >/dev/null
	    fi
	else
	    # The sub-repo directory is already present. Navigate to it.
	    pushd $DIR >/dev/null

	    # Determine the currently checked out branch of the sub-repo.
	    local BRANCH=$(git branch | grep '^*' | sed 's/* //')
	    if [[ "$BRANCH" == "(no branch)" ]]; then
		local REFLOG=$(git reflog -n1)
		CPIN=${REFLOG%% *}
	    else
		CPIN=$BRANCH
	    fi

	    # If they differ, ask how we're expected to handle it.
	    if [[ -n $PIN && $CPIN != $PIN ]]; then
		echo -e "\033[1;37;41m $DIR($CPIN) -- $REMOTE \033[0m"
		echo "Your current pin does not match the specified sub-repo pin: $PIN"
		echo "What would you like to do?"
		echo " s) switch to the specified sub-repo pin (default, will checkout the sub-repo to the .gitrepos pin)"
		echo " k) keep the current pin (make no changes)"
		echo " o) overwrite the .gitrepos pin with the current pin"
		if [[ -n $CHOICEOPT ]]; then
		    CHOICE=$CHOICEOPT
		else
		    read -u 10 CHOICE
		fi

		case ${CHOICE:=s} in
		    s)  ;;
		    k)  continue;;
		    o)  popd >/dev/null;
			_checkout $DIR $CPIN;
			pushd $DIR >/dev/null;
			continue;;
		    *)  echo "Invalid choice: $CHOICE. Stopping." >&2;
			return 1;;
		esac
	    else
		echo -e "\033[30;47m $DIR($PIN) -- $REMOTE \033[0m"
	    fi
	    
	    if ! git fetch; then
		echo "Failed to fetch $PIN" >&2
		return 1
	    fi
	    
	    if [[ -n $PIN ]] && ! git checkout $PIN; then
		echo "Failed to checkout $PIN" >&2
		return 1
	    fi
	    
	    # If we don't have a pin from the .gitrepos
	    # file, go ahead and use the current checkout.
	    PIN=${PIN:-$CPIN}

	    # If we're on a branch and that branch has an upstream but we fail to pull
	    if [[ -z $COMMIT ]] && git rev-parse @{u} &>/dev/null && ! git pull $REBASE; then
		echo "Failed to merge changes from $PIN. Resolve these issues and update again" >&2
		return 1
	    fi
	    popd >/dev/null
	fi

        # Recurse to this sub-repo if it has a .gitrepos file
	if [[ -n $RECURSE && -e $DIR/.gitrepos ]]; then
	    echo "Recursing to $DIR"
	    pushd $DIR >/dev/null
	    if ! $BASH_SOURCE update ${ARGS[@]}; then
		echo "Failed to update $DIR" >&2
		return 1
	    fi
	    popd >/dev/null
	fi
    done < <(
	if [[ -n $REPOS ]]; then
	    for REPO in ${REPOS[@]}; do 
		grep "^$REPO " $FILE
	    done
        else
	    cat $FILE
        fi)
}

function _publish {
    local MESSAGE="Updating sub-repos" PUSH
    
    local OPTARG OPTIND OPTERR OPT CHOICE
    while getopts ":m:p" OPT; do
	case $OPT in
	    m) MESSAGE="$OPTARG";;
	    p) PUSH=1;;
	esac
    done
    shift $((OPTIND-1))

    if [[ $(git diff --name-only --cached | wc -l) != 0 ]]; then
	echo "Staged changes found. Please commit or remove them before continuing" >&2
	return 1
    fi
    
    local DIR REMOTE PIN COMMIT
    while read LINE; do
	read DIR REMOTE PIN <<< $(echo $LINE)
	if [[ ! -e $DIR ]]; then
	    echo "Sub-repo directory does not exist locally. Try running 'git subrepo update' first." >&2
	    return 1
	fi
	
	# See if the sub-repo is pinned to a particular commit.
	if [[ ${PIN:0:2} == "!!" ]]; then
	    COMMIT=1
	    PIN=${PIN:2}
	fi
	
	pushd $DIR >/dev/null

	if ! git fetch &>/dev/null; then
	    echo "Failed to fetch remote changes." >&2
	    return 1
	fi
	
	if [[ -n $COMMIT ]]; then
	    if ! git branch -r --contains $PIN &>/dev/null; then
		echo "$DIR reference $PIN not pushed to $REMOTE yet" >&2
		return 1
	    fi
	elif [[ -n $PIN ]]; then
	    if ! git branch -r | grep -q "origin/$PIN"; then
		echo "$DIR branch $PIN does not exist on $REMOTE yet" >&2
		return 1
	    fi
	fi

	popd >/dev/null

    done < .gitrepos

    if [[ -z $PUSH ]]; then
	echo -n "Ready to commit and push. Continue? (Y/n) "
	read CHOICE
	case $CHOICE in
	    ''|y|Y) ;;
	    *) echo "Aborting publish" >&2; return 1;;
	esac
    fi

    # Let's do it.
    git add .gitrepos .gitignore
    git commit -m "$MESSAGE"
    git push
}

function _checkout {
    local DIR=$1 PIN=$2 REMOTE LINE 

    if ! LINE=$(grep "^$DIR " .gitrepos); then
	echo "Unknown sub-repo" >&2
    elif [[ ! -e $DIR ]]; then
	echo "Could not find sub-repo at $DIR. Try using 'git subrepo add'" >&2
    elif [[ -n $PIN ]]; then
	REMOTE=$(echo $LINE | cut -d' ' -f2)
	pushd $DIR >/dev/null
	echo -e "\033[30;47m $DIR($PIN) -- $REMOTE \033[0m"
	if git checkout $PIN; then
	    if git branch | grep -q "(no branch)"; then
		PIN="!!$PIN"
	    fi
	    popd >/dev/null
	    
	    REMOTE=$(echo $REMOTE | sed "s/\//\\\\\//g")
	    sed -i "s/^$DIR .*/$DIR $REMOTE $PIN/" .gitrepos
	else
	    echo "Failed to checkout $PIN" >&2
	    popd >/dev/null
	    return 1
	fi
	echo
    else
	REMOTE=$(echo $LINE | cut -d' ' -f2 | sed "s/\//\\\\\//g")
	sed -i "s/^$DIR .*/$DIR $REMOTE/" .gitrepos
    fi
}

function _list {
    local DIR REMOTE PIN CPIN PIN_ERR_BEGIN REM_ERR_BEGIN ERR_END="\033[0m"
    local FORMAT="%-20s %b%-15s %-15s%b %b%s%b\n"
    printf "$FORMAT" "Path" "$PIN_ERR_BEGIN" ".gitrepos Pin" "Current Pin" "$ERR_END" "$REM_ERR_BEGIN" "Remote" "$ERR_END"
    echo "------------------------------------------------------------------------------------"
    while read LINE; do
	read DIR REMOTE PIN <<< $(echo $LINE)
	
	if [[ ! -e $DIR ]]; then
	    CPIN="(not present)"
	    PIN_ERR_BEGIN="\033[1;37;41m"
	    REM_ERR_BEGIN=
	else
	    pushd $DIR >/dev/null
	    
	    local BRANCH=$(git branch | grep '^*' | sed 's/* //')
	    if [[ "$BRANCH" == "(no branch)" ]]; then
		local REFLOG=$(git reflog -n1)
		CPIN=${REFLOG%% *}
	    else
		CPIN=$BRANCH
	    fi
	    [[ -z $PIN ]] || [[ $PIN == $CPIN ]] && PIN_ERR_BEGIN= || PIN_ERR_BEGIN="\033[1;37;41m"
	    git remote -v | grep -q "origin[[:space:]]\+$REMOTE" && REM_ERR_BEGIN= || REM_ERR_BEGIN="\033[1;37;41m"
	    
	    popd >/dev/null
	fi
	
	printf "$FORMAT" "$DIR" "$PIN_ERR_BEGIN" "${PIN:---}" "$CPIN" "$ERR_END" "$REM_ERR_BEGIN" "$REMOTE" "$ERR_END"
    done < .gitrepos
}

# Move to the top-level git dir
cd $(git rev-parse --show-toplevel)

COMMAND=${1:-list}
case $COMMAND in
    # Require a .gitrepos file for these commands
    list|rm|update|publish|checkout) shift
        if [[ ! -e .gitrepos ]]; then
            echo "No sub-repos configured for this repository. Use 'git subrepo add' to get started." >&\2
            exit 1
        fi
        _$COMMAND "${@}"
        ;;
    
    # These do not require a .gitrepos file
    add|help|install|uninstall) shift
        _$COMMAND "${@}"
        ;;
    *)  echo "Unknown sub-repo command '$COMMAND'" >&2
        exit 1
        ;;
esac
