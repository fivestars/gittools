#! /bin/bash

function _help {
    echo "\
Usage: git subrepo [list]
   or: git subrepo install [--local] [--global] [--core]
   or: git subrepo uninstall [--local] [--global] [--core]
   or: git subrepo add [-r] [<dir>] <remote> [<branch>|<hash>]
   or: git subrepo rm [-r] <dir1> <dir2>...
   or: git subrepo update [--top] [--rebase] [-r] [--file=<.gitrepos file>] [<dir1>] [<dir2>]...
   or: git subrepo publish [-m <message>] [-p]
   or: git subrepo checkout <dir> [<branch>|<hash>]
   or: git subrepo help

Operations:
    list: Lists the current subrepos for this repository.

    install: Installs 'git-subrepo' into any of three locations.
             --local: The repository's aliases (default)
             --global: Your global aliases
             --core: Copies this file into this machine's git core 
                     directory. Any 'subrepo' aliases will no longer
                     be effective.

    uninstall: Undoes the effects of 'install'.

    add: Adds a new repository as a sub repo. This will create an
         entry in the .gitrepos file and clone the repository
         to <dir>. If <branch> or <hash> is given, the repository
         will be checked out to that ref-spec. If -r is given,
         'git subrepo update -r' the new subrepo.

    rm: Removes a sub repo from this repository. This removes the
        sub repo's entry from the .gitrepos file. If the -r option
        is given, the sub repo's directory will be removed from
        the working directory as well.

    update: Clones any new repositories found in the .gitrepos
            file and pulls in any changes in existing sub repos. 
            --top: Perform a pull on this top-level repo first.
            --rebase: Perform a rebase rather than a merge when
                      pulling commits from the sub repos' origins.
            --file: Use the given file rather than the local 
                    .gitrepos file.
            -r: Recurse through our subrepos and update them as well.
                Any specified <dir>s and the argument to the --file
                option will only apply to the top-level repository 
                in which this command is being invoked.

    publish: Safely pushes changes to the .gitrepos file.
             It iterates through the subrepo list in the .gitrepos 
             file and verifies that they are checked out locally 
             and that the specified refs(pins) are present in their 
             remote repositories.
             You are then prompted to continue with the 
             add-commit-push of the .gitrepos file. If the -p 
             option is provided, the prompt will be suppressed, 
             and it will proceed as if you had entered 'y'.
             You can provide a commit message with -m.

    checkout: Checks out a subrepo to the given ref-spec. This
              will update the sub repo's entry in the .gitrepos
              file to reflect this change as well.

    help: Displays this help message.
"
}

function _install {
    local TOKENS TOKEN LOCAL GLOBAL CORE CHOICE 
    [[ -z $@ ]] && LOCAL=2
    read -a TOKENS <<< "$@"
    for TOKEN in ${TOKENS[@]}; do
	case $TOKEN in
	    --local) shift; LOCAL=1;;
	    --global) shift; [[ $LOCAL == 2 ]] && LOCAL=; GLOBAL=1;;
	    --core) shift; [[ $LOCAL == 2 ]] && LOCAL=; CORE=1;;
	    *) echo "Unknown option: $TOKEN"; return 1;; 
	esac
    done
    
    if [[ -n $LOCAL ]]; then
	git config alias.subrepo '!$(git rev-parse --show-toplevel)/git-subrepo' && \
	    echo "Added to your repository's aliases."
    fi

    if [[ -n $GLOBAL ]]; then
	git config --global alias.subrepo "!$(git rev-parse --show-toplevel)/git-subrepo" && \
	    echo "Added to your global aliases."
    fi

    if [[ -n $CORE ]]; then
	echo "This will supercede any subrepo aliases on this machine."
	echo -n "Continue? (y/N) "
	read CHOICE
	case $CHOICE in
	    y|Y) cp $BASH_SOURCE $(git --exec-path) && \
		echo "Copied to $(git --exec-path)/git-subrepo" || \
		echo "Could not copy to $(git --exec-path)/git-subrepo";;
	esac
    fi
}

function _uninstall {
    local TOKENS TOKEN LOCAL GLOBAL CORE CHOICE
    [[ -z $@ ]] && LOCAL=2
    read -a TOKENS <<< "$@"
    for TOKEN in ${TOKENS[@]}; do
	case $TOKEN in
	    --local) shift; LOCAL=1;;
	    --global) shift; [[ $LOCAL == 2 ]] && LOCAL=; GLOBAL=1;;
	    --core) shift; [[ $LOCAL == 2 ]] && LOCAL=; CORE=1;;
	esac
    done
    
    if [[ -n $LOCAL ]]; then
	git config --unset alias.subrepo && \
	    echo "Removed from your repository's aliases."
    fi

    if [[ -n $GLOBAL ]]; then
	git config --global --unset alias.subrepo && \
	    echo "Removed from your global aliases."
	
    fi

    if [[ -n $CORE && -e "$(git --exec-path)/git-subrepo" ]]; then
	echo "This will remove 'git subrepo' from this machine."
	echo -n "Continue? (y/N) "
	read CHOICE
	case $CHOICE in
	    y|Y) rm -f "$(git --exec-path)/git-subrepo" && \
		echo "Deleted $(git --exec-path)/git-subrepo" || \
		echo "Could not remove from $(git --exec-path)";;
	esac
    fi
}

function _add {
    local DIR REMOTE REF RECURSE
    local OPTARG OPTIND OPTERR OPT DELETE DIR
    while getopts ":r" OPT; do
	case $OPT in
	    r) RECURSE=1;;
	esac
    done
    shift $((OPTIND-1))

    if echo $1 | grep -q "\.git$"; then
	read REMOTE REF <<< $@
	DIR=$(echo $REMOTE | sed 's/\(.*[:/]\|^\)\([^:/]\+\)\.git/\2/')
    else
	read DIR REMOTE REF <<< $@
    fi
    REF=${REF:-master}
    
    touch .gitrepos
    if grep -q "^$DIR " .gitrepos; then
	echo "subrepo already exists as "$(grep "^$DIR " .gitrepos) >&2
	return 1
    elif [[ -e $DIR ]]; then
	echo "$DIR is already present. Move aside or choose another location for your subrepo." >&2
	return 1
    fi

    # Prevent using relative file paths
    if [[ ${REMOTE:0:1} != '/' && ${REMOTE:0:8} != 'file:///' && -e $REMOTE ]]; then
	echo "Cannot add a repository using a relative filepath" >&2
	return 1
    fi

    if git clone -b $REF $REMOTE $DIR; then
	echo $DIR $REMOTE $REF >> .gitrepos
	echo $DIR >> .gitignore

	if [[ -n $RECURSE && -e $DIR/.gitrepos ]]; then	
	    echo "Recursing to $DIR"
	    pushd $DIR &>/dev/null
	    if ! $BASH_SOURCE update -r; then
		echo "Failed to update $DIR" >&2
		return 1
	    fi
	    popd &>/dev/null
	fi 
    fi
}

function _rm {
    local OPTARG OPTIND OPTERR OPT DELETE DIR
    while getopts ":r" OPT; do
	case $OPT in
	    r) DELETE=1;;
	esac
    done
    shift $((OPTIND-1))

    for DIR in $@; do
	if grep -q "^$DIR " .gitrepos; then
	    if [[ -n $DELETE ]]; then
		echo "Removing subrepo record and directory"
		rm -rf $DIR
	    else
		echo "Removing subrepo record, leaving directory"
	    fi
	    sed -i'' "/^$DIR /d;/^$/d" .gitrepos
	    if [[ -e .gitignore ]]; then
		sed -i'' "/^${DIR}$/d;/^$/d" .gitignore
	    fi
	else
	    echo "Unknown subrepo" >&2
	fi
    done
}

function _update {
    local ARGS DELETE REPOS REPO DIR REMOTE REF CREF HASH TOP REBASE RECURSE FILE=.gitrepos LINE CHOICE
    
    local TOKENS TOKEN
    read -a TOKENS <<< "$@"
    for TOKEN in ${TOKENS[@]}; do
	case $TOKEN in
	    --rebase) shift; ARGS="${ARGS[@]} $TOKEN"; REBASE=$TOKEN;;
	    --top) shift; ARGS="${ARGS[@]} $TOKEN"; TOP=1;;
	    -r) shift; ARGS="${ARGS[@]} $TOKEN"; RECURSE=1;;
	    --file=*) shift; FILE=${TOKEN#--file=};;
	    *) [[ ${TOKEN:0:2} == "--" ]] && echo "Unknown option: $TOKEN" && return 1;;
	esac
    done
    REPOS="$@"

    # Make sure the .gitrepos file exists
    if [[ ! -e $FILE ]]; then
	echo "No such file or directory: $FILE" >&2
	return 1
    fi

    # Update the top-level repository, if requested
    if [[ -n $TOP ]]; then
	if ! git pull $REBASE; then
	    return 1
	fi
    fi

    # We need to save a reference to the outer stdin here since 
    # we want to read from the keyboard for user input and the 
    # while loop will have its own stdin for reading the .gitrepos
    # file.
    exec 10<&0

    while read LINE; do
	echo
	read DIR REMOTE REF <<< $(echo $LINE)

	# See if the sub repo is pinned to a particular hash.
	if [[ ${REF:0:2} == "!!" ]]; then
	    HASH=1
	    REF=${REF:2}
	fi

	# If the sub repo directory doesn't exist, we must clone it down now
	if [[ ! -e $DIR ]]; then
	    echo -e "\033[1;37;42m $DIR($REF) -- $REMOTE \033[0m"
	    if [[ -z $HASH ]]; then
	        # If it's not a hash, we should be able to clone it
	        # with the branch already checked out.
		if ! git clone -b $REF $REMOTE $DIR; then
		    echo "Failed to clone subrepo" >&2
		    return 1
		fi
	    else
		# Otherwise, we'll clone it normally, then checkout the hash.
		if ! git clone $REMOTE $DIR; then
		    echo "Failed to clone subrepo" >&2
		    return 1
		fi
		pushd $DIR &>/dev/null
		if ! git checkout $REF; then
		    echo "Failed to checkout $REF" >&2
		    return 1
		fi
		popd &>/dev/null
	    fi
    	else
	    # The sub repo directory is already present. Navigate to it.
	    pushd $DIR &>/dev/null

	    # If we detect that the sub repo's remote has changed, force a manual intervention.
	    if ! git remote -v | grep -q "origin[[:space:]]\+$REMOTE"; then
		echo -e "\033[1;37;41m $DIR($REF) -- $REMOTE \033[0m"
		echo "Remote has changed for this subrepo. You must manually remove this directory before updating can proceed." >&2
		return 1
	    fi

	    # Determine the currently checked out branch of the sub repo.
	    local BRANCH=$(git branch | grep '^*' | sed 's/* //')
	    if [[ "$BRANCH" == "(no branch)" ]]; then
		local REFLOG=$(git reflog -n1)
		CREF=${REFLOG%% *}
	    else
		CREF=$BRANCH
	    fi
	    
	    # If they differ, ask how we're expected to handle it.
	    if [[ $CREF != $REF ]]; then
		echo -e "\033[1;37;41m $DIR($CREF) -- $REMOTE \033[0m"
		echo "Your current branch does not match the specified subrepo branch: $REF"
		echo "What would you like to do?"
		echo " k) keep the current branch (default)"
		echo " s) switch to the subrepo branch (will replace the current branch with the subrepo branch)"
		echo " c) checkout the current branch (will set the current branch as the subrepo branch)"
		read -u 10 CHOICE

		[[ -n $CHOICE ]] || CHOICE=k
		case $CHOICE in
		    k) continue;;
		    s) ;;
		    c) _checkout "$DIR" "$CREF";;
		    *) echo "Invalid choice: $CHOICE. Stopping." >&2; return 1;;
		esac
	    else
		echo -e "\033[30;47m $DIR($REF) -- $REMOTE \033[0m"
	    fi
	    
	    if ! { git fetch && git checkout $REF; }; then
		echo "Failed to checkout $REF" >&2
		return 1
	    fi
	    
	    if [[ -z $HASH ]] && ! git pull $REBASE; then
		echo "Failed to merge changes from $REF. Resolve these issues and update again" >&2
		return 1
	    fi
	    popd &>/dev/null
	fi

        # Recurse to this subrepo if it has a .gitrepos file
	if [[ -n $RECURSE && -e $DIR/.gitrepos ]]; then
	    echo "Recursing to $DIR"
	    pushd $DIR &>/dev/null
	    if ! $BASH_SOURCE update ${ARGS[@]}; then
		echo "Failed to update $DIR" >&2
		return 1
	    fi
	    popd &>/dev/null
	fi

    done < <(
	if [[ -n $REPOS ]]; then
	    for REPO in ${REPOS[@]}; do 
		grep "^$REPO " $FILE
	    done
        else
	    cat $FILE
        fi)
}

function _publish {
    local MESSAGE="Updating subrepos" PUSH
    
    local OPTARG OPTIND OPTERR OPT CHOICE
    while getopts ":m:p" OPT; do
	case $OPT in
	    m) MESSAGE="$OPTARG";;
	    p) PUSH=1;;
	esac
    done
    shift $((OPTIND-1))

    if [[ $(git diff --name-only --cached | wc -l) != 0 ]]; then
	echo "Staged changes found. Please commit or remove them before continuing" >&2
	return 1
    fi
    
    local DIR REMOTE REF HASH
    while read LINE; do
	read DIR REMOTE REF <<< $(echo $LINE)
	if [[ ! -e $DIR ]]; then
	    echo "Subrepo directory does not exist locally. Try running 'git subrepo update' first." >&2
	    return 1
	fi
	
	# See if the sub repo is pinned to a particular hash.
	if [[ ${REF:0:2} == "!!" ]]; then
	    HASH=1
	    REF=${REF:2}
	fi
	
	pushd $DIR &>/dev/null

	git fetch >/dev/null
	if [[ -n $HASH ]]; then
	    if ! git branch -r --contains $REF &>/dev/null; then
		echo "$DIR reference $REF not pushed to $REMOTE yet" >&2
		return 1
	    fi
	else 
	    if ! git branch -r | grep -q "origin/$REF"; then
		echo "$DIR branch $REF does not exist on $REMOTE yet" >&2
		return 1
	    fi
	fi

	popd &>/dev/null

    done < .gitrepos

    if [[ -z $PUSH ]]; then
	echo -n "Ready to commit and push. Continue? (Y/n) "
	read CHOICE
	case $CHOICE in
	    ''|y|Y) ;;
	    *) echo "Aborting publish" >&2; return 1;;
	esac
    fi

    # Let's do it.
    git add .gitrepos
    git commit -m "$MESSAGE"
    git push
}

function _checkout {
    local DIR=$1 REF=$2 REMOTE LINE 

    if ! LINE=$(grep "^$DIR " .gitrepos); then
	echo "Unknown subrepo" >&2
    elif [[ ! -e $DIR ]]; then
	echo "Could not find subrepo at $DIR" >&2
    else
	REMOTE=$(echo $LINE | cut -d' ' -f2)
	pushd $DIR &>/dev/null
	echo -e "\033[30;47m $DIR($REF) -- $REMOTE \033[0m"
	if git checkout $REF; then
	    if git branch | grep -q "(no branch)"; then
		REF="!!$REF"
	    fi
	    popd &>/dev/null

	    REMOTE=$(echo $REMOTE | sed "s/\//\\\\\//g")
	    sed -i "s/^$DIR .*/$DIR $REMOTE $REF/" .gitrepos
	else
	    popd &>/dev/null
	fi
	echo
    fi
}

function _list {
    local DIR REMOTE REF CREF REF_ERR_BEGIN REM_ERR_BEGIN ERR_END="\033[0m"
    local FORMAT="%-20s %b%-12s %-12s%b %b%s%b\n"
    printf "$FORMAT" "Path" "$REF_ERR_BEGIN" "Subrepo Ref" "Current Ref" "$ERR_END" "$REM_ERR_BEGIN" "Remote" "$ERR_END"
    echo "----------------------------------------------------------------------------"
    while read LINE; do
	read DIR REMOTE REF <<< $(echo $LINE)
	if [[ ! -e $DIR ]]; then
	    CREF="(not present)"
	    REF_ERR_BEGIN="\033[1;37;41m"
	    REM_ERR_BEGIN=
	else
	    pushd $DIR &>/dev/null
	    
	    local BRANCH=$(git branch | grep '^*' | sed 's/* //')
	    if [[ "$BRANCH" == "(no branch)" ]]; then
		local REFLOG=$(git reflog -n1)
		CREF=${REFLOG%% *}
	    else
		CREF=$BRANCH
	    fi
	    
	    [[ $REF == $CREF ]] && REF_ERR_BEGIN= || REF_ERR_BEGIN="\033[1;37;41m"
	    git remote -v | grep -q "origin[[:space:]]\+$REMOTE" && REM_ERR_BEGIN= || REM_ERR_BEGIN="\033[1;37;41m"
	    
	    popd &>/dev/null
	fi
	
	printf "$FORMAT" "$DIR" "$REF_ERR_BEGIN" "$REF" "$CREF" "$ERR_END" "$REM_ERR_BEGIN" "$REMOTE" "$ERR_END"
    done < .gitrepos
}

# Move to the top-level git dir
cd $(git rev-parse --show-toplevel)

COMMAND=${1:-list}
case $COMMAND in
    # Require a .gitrepos file for these commands
    list|rm|update|publish|checkout) shift
        if [[ ! -e .gitrepos ]]; then
            echo "No sub-repos configured for this repository. Use 'git subrepo add' to get started." >&\2
            exit 1
        fi
        _$COMMAND "${@}"
        ;;
    
    # These do not require a .gitrepos file
    add|help|install|uninstall) shift
        _$COMMAND "${@}"
        ;;
    *)  echo "Unknown subrepo command '$COMMAND'" >&2
        exit 1
        ;;
esac
