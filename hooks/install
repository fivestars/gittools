#! /bin/bash -e

read -r -d '' HELP <<EOF || true
This script installs the git hook multiplexing system into
the current repository ($(git rev-parse --show-toplevel)).
This allows you to configure any number of scripts to run 
for each git hook in either a sequential or parallel manner.

The installation process takes care not to clobber existing 
scripts. Instead, it moves them to the newly created .githooks
directory located at the the top-level repository directory.

Usage:
	install [-c] [-h] <scripts...>

Options:
    -c  Delete all scripts from .git/hooks and .githooks that match
        the standare git hooks' names prior to installing the
        multiplexing scripts for each. This is a cleanup step that
        may become necessary if you run the install script multiple
        times and the multiplexer script is lexically different than
        what is currently installed.

    -h  Displays this help

Arguments:
    <scripts...>    A list of script filenames to be run for this
                    repository. They should be bash scripts of the 
                    form <git hook name>-XXXX.

                    The valid git hook names are:
                        applypatch-msg
                        commit-msg
                        post-checkout
                        post-commit
                        post-merge
                        post-receive
                        post-update
                        pre-applypatch
                        pre-commit
                        prepare-commit-msg
                        pre-rebase
                        pre-receive update

                    Examples: 
                        commit-msg-jira
                        pre-commit-unittest
EOF

HOOKS=( applypatch-msg commit-msg post-checkout post-commit post-merge post-receive post-update pre-applypatch pre-commit prepare-commit-msg pre-rebase pre-receive update )

CLEAR=false
while getopts ":ch" OPT; do
	case $OPT in
		c) CLEAR=true;;
		h) echo "$HELP" | less; exit;;
	esac
done
shift $((OPTIND-1))

# Confirm that we're in a git repo
if ! GITDIR=$(git rev-parse --git-dir 2>/dev/null); then
	echo "Not in a git repository" && exit 1
fi
pushd $GITDIR/.. >/dev/null && REPO=$(git rev-parse --show-toplevel) && popd >/dev/null
pushd $REPO >/dev/null && GITDIR=$REPO/$(git rev-parse --git-dir) && popd >/dev/null

# Find where this script is being called from
SRCDIR=$(dirname "$BASH_SOURCE")

# Install the git-hooks
cat <<EOF
Installing hooks:
	Copying any existing hooks to $REPO/.githooks
EOF

[[ ! -e $REPO/.githooks ]] && FIRSTTIME=true || FIRSTTIME=false
mkdir -p $REPO/.githooks

for hook in ${HOOKS[*]}; do
	if $CLEAR; then
		rm -f $GITDIR/hooks/$hook $REPO/.githooks/$hook
	elif [[ -e $GITDIR/hooks/$hook && $(diff $SRCDIR/runner $GITDIR/hooks/$hook | wc -l) > 0 ]]; then
		if $FIRSTTIME; then
			mv -v $GITDIR/hooks/$hook $REPO/.githooks/$hook-moved
		else
			mv -v --backup=t $GITDIR/hooks/$hook $REPO/.githooks/
		fi
	fi
	cp --backup=t $SRCDIR/runner $GITDIR/hooks/$hook
done

# Sample script to demonstrate new hook functionality
cp --backup=t $SRCDIR/example-hooks/commit-msg-jira $REPO/.githooks

# Now that we've installed our basic hooks, we need to give them things
# to run. We do this with the enable_hooks function. Any hooks enabled
# in this fashion are added to this repo's git config settings.
function enable_hooks () {
	local path name prefix hook answer line section
	
	# For each non-base hook, ask if you want to enable it for your repository
	echo
	echo "Enabling Hooks:"
	
	for path in $*; do
		name=$(basename $path)
	
		if [[ '/' != ${path:0:1} ]]; then
			# It's a relative path
			pushd $(dirname $path) &>/dev/null
			if [[ $(git rev-parse --show-toplevel) == $REPO ]]; then
				# It's within the repository
				prefix=$(git rev-parse --show-prefix)
				path=$prefix$name
			else
				# It's external to the repository - use absolute path
				path=$PWD/$name
			fi
			popd &>/dev/null
		fi
		
		# Make sure each custom hook is associated with an original git hook
		for hook in ${HOOKS[@]}; do
			(echo $name | grep -q ^"$hook-") && break || hook=
		done
		if [[ -z $hook ]]; then
			echo "	Could not determine which git-hook \"$name\" is intended for. Prefix your hook with a proper git-hook name"
			continue
		fi
		
		# Add a path entry to the config for this hook script and enable it
		git config --path hooks.$name.path $path
		git config --bool hooks.$name.enabled true
	done
	
	if git config --get-regexp "^hooks\..*\.enabled$" "true" &>/dev/null || [[ -n $(ls -A .githooks/) ]]; then
		echo -e "\nEnabled Hooks:"
		while read line; do
			if ! git config --get-regexp hooks\.$line\.enabled false &>/dev/null; then
				echo "	$PWD/$line"
			fi
		done < <(ls $REPO/.githooks | grep -f <(echo ${HOOKS[*]} | xargs -n1 | sed s/^/^/g ))
		while read line; do
			section=${line%.enabled true}
			path=$(git config $section.path)
			echo "	$path"
		done < <(git config --get-regexp "^hooks\..*\.enabled$" "true")
	fi
}

# It's possible they're trying to enable hooks from a location other than .githooks
[[ -n $* ]] || enable_hooks $*

cat <<EOF

Installation Complete:
	You can enable/disable your hooks now by modifying your git config:
		git config --get-regexp hooks.*
		git config --bool  hooks.<hook script name>.enabled true|false
		git config --unset hooks.<hook script name>.enabled
EOF
