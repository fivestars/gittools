#! /bin/bash -e

read -r -d '' HELP <<EOF || true
This script installs the git hook multiplexing system into
the current repository ($(git rev-parse --show-toplevel)).
This allows you to configure any number of scripts to run 
for each git hook in either a sequential or parallel manner.

The installation process takes care not to clobber existing 
scripts. Instead, it moves them to the newly created .githooks
directory located at the the top-level repository directory.

Usage:
	install [-e] [-h] <scripts...>

Options:
    -e  Create example hooks in the new .githooks directory
    
    -h  Displays this help

Arguments:
    <scripts...>    A list of script filenames to be run for this
                    repository. They should be bash scripts of the 
                    form <git hook name>-XXXX.

                    The valid git hook names are:
                        applypatch-msg
                        commit-msg
                        post-checkout
                        post-commit
                        post-merge
                        post-receive
                        post-update
                        pre-applypatch
                        pre-commit
                        prepare-commit-msg
                        pre-rebase
                        pre-receive update

                    Examples: 
                        commit-msg-jira
                        pre-commit-unittest
EOF

HOOKS=( applypatch-msg commit-msg post-checkout post-commit post-merge post-receive post-update pre-applypatch pre-commit prepare-commit-msg pre-rebase pre-receive update )

EXAMPLES=false
while getopts ":eh" OPT; do
	case $OPT in
		e) EXAMPLES=true;;
		h) echo "$HELP" | less; exit;;
	esac
done
shift $((OPTIND-1))

# Confirm that we have repository and a work tree
if ! GITDIR=$(git rev-parse --git-dir); then
	echo "Git dir required but not found" && exit 1
fi
if ! REPO=$(git rev-parse --show-toplevel) || [[ -z $REPO ]]; then
	echo "Work tree required but not found" && exit 1
fi
pushd GITDIR &>/dev/null && GITDIR=$PWD && popd &>/dev/null
pushd REPO &>/dev/null && REPO=$PWD && popd &>/dev/null

# Find where this script is being called from
SRCDIR=$(dirname "$BASH_SOURCE")

# Check for valid .git/hooks dir
if [[ -h $GITDIR/hooks ]]; then
	LINK=$(readlink $GITDIR/hooks)
	echo "Warning: $GITDIR/hooks is a symlink to $LINK"
	echo -n "Unlink and proceed? (Y/n) "
	read ANSWER
	case $ANSWER in
		""|y|Y) ;;
		*) echo "Stopping"; exit 1;;
	esac
	rm $GITDIR/hooks
	mkdir $GITDIR/hooks
	if ls $GITDIR/$LINK/* &>/dev/null; then
		cp -rv $GITDIR/$LINK/* $GITDIR/hooks
	fi
fi

# Install the git-hooks
cat <<EOF
Installing hooks:
	Copying any existing hooks to $REPO/.githooks
EOF

# Create the .githooks dir
[[ ! -e $REPO/.githooks ]] && FIRSTTIME=true || FIRSTTIME=false
mkdir -p $REPO/.githooks $GITDIR/hooks

# Move existing hooks to .githooks dir and copy runner script over
for hook in ${HOOKS[*]}; do
	if $FIRSTTIME && [[ -e $GITDIR/hooks/$hook ]]; then
		mv -v $GITDIR/hooks/$hook $REPO/.githooks/$hook-moved | sed "s/^/	/"
	fi
	cp $SRCDIR/runner $GITDIR/hooks/$hook
	chmod +x $GITDIR/hooks/$hook
done

# Sample script to demonstrate new hook functionality
$EXAMPLES && cp $SRCDIR/example-hooks/commit-msg-jira $REPO/.githooks

# Now that we've installed our basic hooks, we need to give them things
# to run. We do this with the enable_hooks function. Any hooks enabled
# in this fashion are added to this repo's git config settings.
function enable_hooks () {
	local path name prefix hook answer line section
	
	# For each non-base hook, ask if you want to enable it for your repository
	[[ -n $* ]] && echo -e "\nEnabling Hooks:"
	
	for path in $*; do
		name=$(basename $path)
	
		if [[ '/' != ${path:0:1} ]]; then
			# It's a relative path
			pushd $(dirname $path) &>/dev/null
			if [[ $(git rev-parse --show-toplevel) == $REPO ]]; then
				# It's within the repository
				prefix=$(git rev-parse --show-prefix)
				path=$prefix$name
			else
				# It's external to the repository - use absolute path
				path=$PWD/$name
			fi
			popd &>/dev/null
		fi
		
		# Make sure each custom hook is associated with an original git hook
		for hook in ${HOOKS[@]}; do
			(echo $name | grep -q ^"$hook-") && break || hook=
		done
		if [[ -z $hook ]]; then
			echo "	Could not determine which git-hook \"$name\" is intended for. Prefix your hook with a proper git-hook name"
			continue
		fi
		
		# Add a path entry to the config for this hook script and enable it
		git config --path hooks.$name.path $path
		git config --bool hooks.$name.enabled true
	done
	
	if git config --get-regexp "^hooks\..*\.enabled$" "true" &>/dev/null || [[ -n $(ls -A .githooks/) ]]; then
		echo -e "\nEnabled Hooks:"
		while read line; do
			if [[ $line == ${line%\~} ]] && ! git config --get-regexp hooks\.$line\.enabled false &>/dev/null; then
				echo "	$PWD/$line"
			fi
		done < <(ls $REPO/.githooks | grep -f <(echo ${HOOKS[*]} | xargs -n1 | sed s/^/^/g ))
		while read line; do
			section=${line%.enabled true}
			path=$(git config $section.path)
			echo "	$path"
		done < <(git config --get-regexp "^hooks\..*\.enabled$" "true")
	fi
}

# It's possible they're trying to install hooks from a location other than .githooks
[[ -n $* ]] || enable_hooks $*

cat <<EOF

Installation Complete:
	You can enable/disable your hooks now by modifying your git config:
		git config --get-regexp hooks
		git config --bool  hooks.<hook script name>.enabled true|false
		git config --unset hooks.<hook script name>.enabled

EOF
