#! /bin/bash -e

# Make sure we're not accidentally being called from another runner script
[[ -z $HOOK ]] && export HOOK=$(basename "$0") || exit

# This script will run all configured hooks found in <repository>/.githooks
# and all hooks found by running:
#
#	git config --get-regexp hooks.$HOOK.enabled true
#
# It will fail if any of those fail on a command (see 'bash -e') or if 
# they return non-zero exit codes. You can disable hooks through git
# configs:
#
#	# Disable all custom hooks for this git hook
#	git config --bool hooks.$HOOK.enabled false
#
#	# Disable an individual custom hook
#	git config --bool hooks.<custom hook>.enabled false
#
# The hooks will be run sequentially by default for safety.
# If you determine that your hooks can be run in parallel, enable it with:
#
#	git config --int hooks.$HOOK.parallel <num>
#
# where <num> is the number of jobs you wish to start. If 0, <num> will
# match the number of CPUs on the machine. When running in parallel,
# each hook's output will be buffered until complete. If you choose to not
# run your hooks in parallel, the output will not be buffered.
#
# For safety, you can check for parallel execution in your hook by calling
# the prevent-parallel function. It checks the value of
# "git config hooks.$HOOK.parallel" and fails if it is set to anything but 1.
#
#	Example:
#		#! /bin/bash
#		prevent-parallel   # Will fail the hook unless it is being run sequentially.
#
# In addition, you have the option of configuring your hooks to continue even if
# one fails. If any fail, the overall hook will still fail. This just lets you see
# multiple failures for one invocation of the hook scripts. Enable this behavior
# by using the following:
#
#	git config --bool hooks.continue true|false
#	git config --bool hooks.$HOOK.continue true|false
#
# The more precise $HOOK setting will take precedence over the general one.
# These continue configs will be ignored if the hooks are run in parallel.

CAPTURE=/tmp/capture

cat <<"EOF" >$CAPTURE
#! /bin/bash

HALTED=false
function prevent-parallel {
	if is-parallel; then
		echo "${0##*/} cannot be run as a parallel job: git config hooks.$HOOK.parallel is set"
		return 1
	fi
}

function capture_on_exit {
	# Store the exit code
	result=$?

	# Clear the traps
	trap - EXIT SIGHUP SIGINT SIGTERM

	# Fix our stdout and stderr
	is-parallel && exec 1>&11 2>&12 11>&- 12>&-

	# Dump buffer to stdout and delete it
	is-parallel && cat $1 && rm -f $1

	if [[ $result -ne 0 ]]; then
		echo "Failed $HOOK git hook:  $2 (exit code $result)"
	fi
}

# Report which hook is running
echo -e "\nRunning $HOOK git hook: $1"

# Create the temorary output buffer
capture_outfile=$(mktemp)

# Store stdout and stderr, then redirect them to the buffer
is-parallel && exec 11>&1 12>&2 &>$capture_outfile

# Provide the prevent-parallel function to the hook scripts
export -f prevent-parallel

# Set our exit trap to display any errors and do our clean up 
trap "capture_on_exit $capture_outfile $1" EXIT SIGHUP SIGINT SIGTERM

# Call the wrapped script
bash -e $* 2>&1 | sed "s/^/	/"
exit ${PIPESTATUS[0]}
EOF

# Collect the various hooks to run
hooks=
missing=
disabled=

# Look in the default location of .githooks
if ls .githooks/${HOOK}-* &>/dev/null; then
	for hook in .githooks/${HOOK}-*; do
		if [[ -f $hook && ${hook} == ${hook%\~} ]]; then
			if git config --get-regexp hooks.$HOOK.enabled false &>/dev/null \
				|| git config --get-regexp hooks\.${hook##*/}.enabled false &>/dev/null; then
				disabled="${disabled:+$disabled\0}$hook"
			else
				hooks="${hooks:+$hooks\0}$hook"
			fi
		fi
	done
fi

# Make sure that each configured hook can be found,
# Otherwise, fail after running the ones we cound find.
while read line; do
	section=${line%.enabled*}
	path=$(git config $section.path) || path=
	hook=${section#hooks\.}
	if [[ -n $path && ! -e $path ]]; then
		echo "Could not find hook: $hook"
		missing="${missing:+$missing\0}$path"
	elif [[ -z $path ]]; then
		# Probably an explicitly enabled hook
		# in the default .githooks directory
		true
	elif git config --get-regexp hooks.$HOOK.enabled false &>/dev/null; then
		disabled="${disabled:+$disabled\0}$path"
	else
		hooks="${hooks:+$hooks\0}$path"
	fi
done < <(git config --get-regexp hooks\.${HOOK}-.*\.enabled true)

# Display disabled hooks
if [[ -n $disabled ]]; then
	echo -e "\nSkipping disabled hooks:"
	echo -en $disabled | xargs -0 -L1 | sed "s/^/	/"
fi

# Might be done already
if [[ -z $hooks ]] && [[ -z $missing ]]; then
	exit
fi

function is-parallel {
	local jobs=$(git config hooks.$HOOK.parallel)
	[[ -n $jobs && ($jobs == 0 || $jobs -gt 1) ]]
}
export -f is-parallel

if is-parallel; then
	hooks_parallel="-P $(git config hooks.$HOOK.parallel)"
	if [[ 0 == $(git config hooks.$HOOK.parallel) ]]; then
		hooks_parallel="-P $(grep -c processor /proc/cpuinfo)"
	fi

	# Run the hooks through xargs. If any of them fail, xargs will fail and the script
	# will exit with an error code due to the -e at the top of this script.
	echo -en $hooks | xargs -0 -L1 $hooks_parallel -I {} bash -e $CAPTURE {} $*
else
	function run-hooks {
		# $1: true if continue on failure. false if stop on first failure
		local proceed=$1 success=true; shift
		while read hook; do
			$success || echo "Continuing..."
			bash -e $CAPTURE $hook $* || { success=false && $proceed; }
		done < <(sed "s/\0/ \n/g" <<<$*)
		if ! $success; then
			echo -e "\nFailed one or more $HOOK hooks"
			$success
		fi
	}
	run-hooks $(git config hooks.$HOOK.continue || git config hooks.continue || echo false) $hooks $*
fi

# Fail the hook if we couldn't find one of the hook scripts (even though we ran
# the ones we found and encountered no errors)
if [[ -n $missing ]]; then
	echo "Failed $HOOK checks due to missing hooks:"
	echo -en $missing | xargs -0 -L1 | sed "s/^/	/"
	exit 1
fi
