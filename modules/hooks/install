#! /bin/bash -e

HOOKS=( applypatch-msg commit-msg post-checkout post-commit post-merge post-receive post-update pre-applypatch pre-commit prepare-commit-msg pre-rebase pre-receive update )

OVERWRITE_HOOKS=false
SKIP_HOOKS=false
ALL=false
while getopts "im:osa" OPT; do
	case $OPT in
	o) OVERWRITE_HOOKS=true;;
	s) SKIP_HOOKS=true;;
	a) ALL=true;;
	\?) echo "Invalid option: -$OPTARG" >&2; exit 1;;
	esac
done
shift $((OPTIND-1))

# Confirm that we're in a git repo
if [[ $(git rev-parse --is-inside-git-dir 2>/dev/null) != false ]] || \
	! GITDIR=$(git rev-parse --git-dir); then
	echo "Not in a git repository" && exit 1
fi
REPO=$(git rev-parse --show-toplevel)

# Find where this script is being called from
SRCDIR=$(dirname "$BASH_SOURCE")

# Place the capture script in the hooks directory for convenience
cp $SRCDIR/capture $GITDIR/hooks

# Install the git-hooks
cat <<EOF
Installing hooks:
	Copying any existing hooks to $REPO/.githooks
EOF
mkdir -p $REPO/.githooks
for hook in ${HOOKS[*]}; do
	if [[ -e $GITDIR/hooks/$hook && $(diff $SRCDIR/runner $GITDIR/hooks/$hook | wc -l) > 0 ]]; then
		mv -v --backup=t $GITDIR/hooks/$hook $REPO/.githooks/
	fi
	cp --backup=t $SRCDIR/runner $GITDIR/hooks/$hook
done

# Now that we've installed our basic hooks, we need to give them things
# to run. We do this with the enable_hooks function. Any hooks enabled
# in this fashion are added to this repo's git config settings.
function enable_hooks () {
	local path name prefix hook answer line section
	
	# For each non-base hook, ask if you want to enable it for your repository
	echo
	echo "Enabling Hooks:"
	echo $* | tr ' ' '\0' | xargs -0 -I {} echo -e "	$PWD/"{}
	
	for path in $*; do
		name=$(basename $path)
	
		if [[ '/' != ${path:0:1} ]]; then
			# It's a relative path
			pushd $(dirname $path) &>/dev/null
			if [[ $(git rev-parse --show-toplevel) == $REPO ]]; then
				# It's within the repository
				prefix=$(git rev-parse --show-prefix)
				path=$prefix$name
			else
				# It's external to the repository - use absolute path
				path=$PWD/$name
			fi
			popd &>/dev/null
		fi
		
		# Make sure each custom hook is associated with an original git hook
		for hook in ${HOOKS[@]}; do
			(echo $name | grep -q ^"$hook-") && break || hook=
		done
		if [[ -z $hook ]]; then
			echo "	Could not determine which git-hook \"$name\" is intended for. Prefix your hook with a proper git-hook name"
			continue
		fi
		
		# Add a path entry to the config for this hook script
		git config --path hooks.$hook.$name.path $path

		# Prompt them to enable each one (unless given '-a')
		if ! (git config --get-regexp "^hooks\.$hook\.$name\.enabled$" "true" &>/dev/null); then
			if ! $ALL; then
				echo -ne "	Enable $name for this repository? (Y/n) "
				read answer
			fi
			case $answer in
				""|y|Y) git config --bool hooks.$hook.$name.enabled true;;
				*) echo "		Skipped $name";;
			esac
		else
			echo "	$name already enabled"
		fi
	done
	
	if git config --get-regexp "^hooks.*\.enabled$" "true" &>/dev/null; then
		echo -e "\nEnabled Hooks:"
		while read line; do
			if ! git config --get-regexp hooks\..*\.$line\.enabled false &>/dev/null; then
				echo "	$PWD/$line"
			fi
		done < <(ls $REPO/.githooks | grep -f <(echo ${HOOKS[*]} | xargs -n1 | sed s/^/^/g ))
		while read line; do
			section=${line%.enabled true}
			path=$(git config $section.path)
			echo "	$path"
		done < <(git config --get-regexp "^hooks.*\.enabled$" "true")
	fi
}

# It's possible they're trying to enable hooks from a location other than .githooks
[[ -n $* ]] && enable_hooks $*

cat <<EOF

Installation Complete:
	You can enable/disable your hooks now by modifying your git config:
		git config --get-regexp hooks.*
		git config --bool  hooks.<githook name>.<hook script name>.enabled true|false
		git config --unset hooks.<githook name>.<hook script name>.enabled
EOF
