#! /bin/bash -e

read -r -d '' HELP <<EOF || true
This script installs the git hook multiplexing system into
the current repository ($(git rev-parse --show-toplevel)).
This allows you to configure any number of scripts to run 
for each git hook in either a sequential or parallel manner.

The installation process takes care not to clobber existing 
scripts. Instead, it moves them to the newly created .githooks
directory located at the the top-level repository directory.

Usage: install [-a] [-c] <scripts...>

Options:
    -a  When <scripts...> are provided, automatically enable them
        by default. Otherwise, you will be prompted to enable each
        one during the installation process.

    -c  Delete all scripts from .git/hooks and .githooks that match
        the standare git hooks' names prior to installing the
        multiplexing scripts for each. This is a cleanup step that
        may become necessary if you run the install script multiple
        times and the multiplexer script is lexically different than
        what is currently installed.

    -h  Displays this help

Arguments:
    <scripts...>    A list of script filenames to be run for this
                    repository. They should be bash scripts of the 
                    form <git hook name>-XXXX.

                    The valid git hook names are:
                        applypatch-msg
                        commit-msg
                        post-checkout
                        post-commit
                        post-merge
                        post-receive
                        post-update
                        pre-applypatch
                        pre-commit
                        prepare-commit-msg
                        pre-rebase
                        pre-receive update

                    Examples: 
                        pre-commit-unittest
                        commit-msg-syntax
EOF

HOOKS=( applypatch-msg commit-msg post-checkout post-commit post-merge post-receive post-update pre-applypatch pre-commit prepare-commit-msg pre-rebase pre-receive update )

ALL=false
CLEAR=false
while getopts "ach" OPT; do
	case $OPT in
	a) ALL=true;;
	c) CLEAR=true;;
	h) echo "$HELP" | less; exit;;
	\?) echo "Invalid option: -$OPTARG" >&2; exit 1;;
	esac
done
shift $((OPTIND-1))

# Confirm that we're in a git repo
if [[ $(git rev-parse --is-inside-git-dir 2>/dev/null) != false ]] || \
	! GITDIR=$(git rev-parse --git-dir); then
	echo "Not in a git repository" && exit 1
fi
REPO=$(git rev-parse --show-toplevel)

# Find where this script is being called from
SRCDIR=$(dirname "$BASH_SOURCE")

# Place the capture script in the hooks directory for convenience
cp $SRCDIR/capture $GITDIR/hooks

# Install the git-hooks
cat <<EOF
Installing hooks:
	Copying any existing hooks to $REPO/.githooks
EOF
mkdir -p $REPO/.githooks
for hook in ${HOOKS[*]}; do
	if $CLEAR; then
		rm -f $GITDIR/hooks/$hook $REPO/.githooks/$hook
	elif [[ -e $GITDIR/hooks/$hook && $(diff $SRCDIR/runner $GITDIR/hooks/$hook | wc -l) > 0 ]]; then
		mv -v --backup=t $GITDIR/hooks/$hook $REPO/.githooks/
	fi
	cp --backup=t $SRCDIR/runner $GITDIR/hooks/$hook
done


# Now that we've installed our basic hooks, we need to give them things
# to run. We do this with the enable_hooks function. Any hooks enabled
# in this fashion are added to this repo's git config settings.
function enable_hooks () {
	local path name prefix hook answer line section
	
	# For each non-base hook, ask if you want to enable it for your repository
	echo
	echo "Enabling Hooks:"
	echo $* | tr ' ' '\0' | xargs -0 -I {} echo -e "	$PWD/"{}
	
	for path in $*; do
		name=$(basename $path)
	
		if [[ '/' != ${path:0:1} ]]; then
			# It's a relative path
			pushd $(dirname $path) &>/dev/null
			if [[ $(git rev-parse --show-toplevel) == $REPO ]]; then
				# It's within the repository
				prefix=$(git rev-parse --show-prefix)
				path=$prefix$name
			else
				# It's external to the repository - use absolute path
				path=$PWD/$name
			fi
			popd &>/dev/null
		fi
		
		# Make sure each custom hook is associated with an original git hook
		for hook in ${HOOKS[@]}; do
			(echo $name | grep -q ^"$hook-") && break || hook=
		done
		if [[ -z $hook ]]; then
			echo "	Could not determine which git-hook \"$name\" is intended for. Prefix your hook with a proper git-hook name"
			continue
		fi
		
		# Add a path entry to the config for this hook script
		git config --path hooks.$hook.$name.path $path

		# Prompt them to enable each one (unless given '-a')
		if ! (git config --get-regexp "^hooks\.$hook\.$name\.enabled$" "true" &>/dev/null); then
			if ! $ALL; then
				echo -ne "	Enable $name for this repository? (Y/n) "
				read answer
			fi
			case $answer in
				""|y|Y) git config --bool hooks.$hook.$name.enabled true;;
				*) echo "		Skipped $name";;
			esac
		else
			echo "	$name already enabled"
		fi
	done
	
	if git config --get-regexp "^hooks.*\.enabled$" "true" &>/dev/null; then
		echo -e "\nEnabled Hooks:"
		while read line; do
			if ! git config --get-regexp hooks\..*\.$line\.enabled false &>/dev/null; then
				echo "	$PWD/$line"
			fi
		done < <(ls $REPO/.githooks | grep -f <(echo ${HOOKS[*]} | xargs -n1 | sed s/^/^/g ))
		while read line; do
			section=${line%.enabled true}
			path=$(git config $section.path)
			echo "	$path"
		done < <(git config --get-regexp "^hooks.*\.enabled$" "true")
	fi
}

# It's possible they're trying to enable hooks from a location other than .githooks
[[ -n $* ]] && enable_hooks $*

cat <<EOF

Installation Complete:
	You can enable/disable your hooks now by modifying your git config:
		git config --get-regexp hooks.*
		git config --bool  hooks.<githook name>.<hook script name>.enabled true|false
		git config --unset hooks.<githook name>.<hook script name>.enabled
EOF
