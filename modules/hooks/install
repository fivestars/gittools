#! /bin/bash -e

HOOKS=( applypatch-msg commit-msg post-checkout post-commit post-merge post-receive post-update pre-applypatch pre-commit prepare-commit-msg pre-rebase pre-receive update )

OVERWRITE_HOOKS=false
SKIP_HOOKS=false
ALL=false
while getopts "im:osa" OPT; do
	case $OPT in
	o) OVERWRITE_HOOKS=true;;
	s) SKIP_HOOKS=true;;
	a) ALL=true;;
	\?) echo "Invalid option: -$OPTARG" >&2; exit 1;;
	esac
done
shift $((OPTIND-1))

# Confirm that we're in a git repo
if [[ $(git rev-parse --is-inside-git-dir 2>/dev/null) != false ]] || \
	! GITDIR=$(git rev-parse --git-dir); then
	echo "Not in a git repository" && exit 1
fi
REPO=$(git rev-parse --show-toplevel)

# Find where this script is being called from
DIR=$(dirname "$BASH_SOURCE")

# Determine if any git-hooks have already been installed in
# this repo so that we don't accidentally overwrite them.
fifo_src=$(mktemp -u)
fifo_dest=$(mktemp -u)
mkfifo $fifo_src
mkfifo $fifo_dest
trap "rm -f $fifo_src $fifo_dest" EXIT SIGHUP SIGINT SIGTERM

echo ${HOOKS[*]} | xargs -n1  | sort > $fifo_src &
ls --file-type $GITDIR/hooks | sort > $fifo_dest &

present=$(comm -12 $fifo_src $fifo_dest)
rm -f $fifo_src $fifo_dest
trap - EXIT SIGHUP SIGINT SIGTERM

if [[ -n $present ]]; then
	echo
	echo "Detected hooks already installed for this repo:"
	echo $present | xargs -n1 | sed "s/^/	/"
	echo
fi

# Place the capture script in the hooks directory for convenience
cp $DIR/capture $GITDIR/hooks

# Install the git-hooks
cat << EOF
Installing hooks to: $REPO
(Copying any existing hooks to $REPO/.githooks)
EOF
mkdir -p $REPO/.githooks
for hook in ${HOOKS[*]}; do
	if [[ -e $GITDIR/hooks/$hook && $(diff $DIR/runner $GITDIR/hooks/$hook | wc -l) > 0 ]]; then
		mv -v --backup=t $GITDIR/hooks/$hook $REPO/.githooks/
	fi
	cp --backup=t $DIR/runner $GITDIR/hooks/$hook
done

# Now that we've installed our basic hooks, we need to give them things
# to run. We do this with the enable_hooks function. Any hooks enabled
# in this fashion are added to this repo's git config settings.
function enable_hooks () {
	local SRC=$1
	local available
	local hook
	local answer
	
	# For each non-base hook, ask if you want to enable it for your repository
	echo
	echo "Enabling hooks:"
	ls --file-type $SRC | xargs -n1 -I {} echo -e "	"{}
	echo
	
	for available in $(ls --file-type $SRC); do
		hook=
		
		# Make sure each custom hook is associated with an original git hook
		for hook in ${HOOKS[@]}; do
			(echo $available | grep -q ^"$hook-") && break
		done
		if [[ -z $hook ]]; then
			"Could not determine which git-hook \"$available\" is intended for. Prefix your hook with a proper git-hook name"
			continue
		fi
		
		# Prompt them to enable each one (unless given '-a')
		if ! (git config --get-regexp "^hooks\.$hook\.$available\.enabled$" "true"); then
			if ! $ALL; then
				echo -ne "Enable $available for this repository? (Y/n) "
				read answer
			fi
			case $answer in
				""|y|Y) git config --bool hooks.$hook.$available.enabled true;
				*) echo "	Skipped $available"
			esac
		else
			echo "$available already enabled"
		fi
	done
	
	echo -e "\nEnabled hooks:"
	git config --get-regexp "^hooks.*\.enabled$" "true" | sed "s/^/	/g" 
}

# It's possible they're trying to enable hooks from a location other than .githooks
[[ -n $1 ]] && enable_hooks $1

cat << EOF

Any hooks in $REPO/.githooks/ will be enabled by default.

You can enable/disable custom hooks now by modifying your git config:
	git config --get-regexp hooks.*
	git config --bool  hooks.<githook name>.<hook script name>.enabled true|false
	git config --unset hooks.<githook name>.<hook script name>.enabled
EOF
