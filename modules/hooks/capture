#! /bin/sh

# This script will run a given command/script and pass to it any
# provided additional arguments. stdout and stderr will be buffered
# and flushed once complete.

# To be run when this script receives the EXIT signal
function capture_on_exit {
	# Store the exit code
	result=$?

	# Fix our stdout and stderr
	exec 1>&11 2>&12 11>&- 12>&-


	if [[ $result -ne 0 ]]; then
		# Dump buffer to stdout and delete it
		cat $1 && rm -f $1
		echo "Failed git hook:  $2 - exited with error code $result"
	fi
}

function prevent-parallel {
	local jobs=$(git config --get hooks.$HOOK.parallel)

	if [[ -n $jobs && ($jobs == 0 || $jobs -gt 1) ]]; then
		echo "${0##*/} cannot be run as a parallel job: git config hooks.$HOOK.parallel is set"
		return 1
	fi
}

# Report which hook is running
echo "Running git hook: ${1}" 

# Create the temorary output buffer
capture_outfile=$(mktemp)

# Store stdout and stderr, then redirect them to the buffer
exec 11>&1 12>&2 &>$capture_outfile

# Provide the no-parallel function to the hook scripts
export -f prevent-parallel

# Set our exit trap to display any errors and do our clean up 
trap "capture_on_exit $capture_outfile $1" EXIT SIGHUP SIGINT SIGTERM

# Call the wrapped script
bash -e $*
